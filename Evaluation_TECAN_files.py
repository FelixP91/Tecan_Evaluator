import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from scipy.signal import savgol_filter
import os

class Utils():
    '''This class contains methods for calculating the averaged largest slopes of kinetic data generated by a TECAN.'''
    def calculate_slopes(self,kinetc_data, time, interval_):
        '''Calculates the slopes for each interval of n data points.'''
        self.slope_list = []
        for i in range(len(kinetc_data[:-interval_])):
            self.slope_list.append((kinetc_data[i] - kinetc_data[i + interval_]) / (time[i] - time[i + interval_]))
        self.arr = np.array(self.slope_list)
        self.arr = self.arr[~np.isnan(self.arr)]
        return self.arr


    # remove_n_largest= die wie viel größten % an Slopes sollen entfernt werden
    # average_n_slopes= der Mittelwert wie vieler Slopes soll berechnet werden
    def n_largest_slopes(self,slope_list, average_n_slopes=3, remove_n_largest=0.07):
        '''Selcts the n largest slopes from all slopes calculated.
        remove_n_largest= To remove outliers, the n largest values (in %/100) can be removed
        average_n_slopes= to increase the robustness, the average of the n largest slopes can be calculated'''
        self.original_list = list(slope_list)
        self.slope_list = slope_list[:-1]
        self.slope_list.sort()
        if round(len(self.slope_list)*remove_n_largest) > 0:
            self.index_largest_value = round(len(self.slope_list)*remove_n_largest)
        else:
            self.index_largest_value = 0
        self.n_largest_slopes_ = []
        self.indices_n_largest_slopes = []
        for item in range(average_n_slopes):
            self.n_largest_slopes_.append(self.slope_list[::-1][self.index_largest_value + item])
        for value in self.n_largest_slopes_:
            self.indices_n_largest_slopes.append(self.original_list.index(value))
        return [np.array(self.n_largest_slopes_), self.indices_n_largest_slopes]

    def create_output_file(self, input_file, output_file, interval_,run_images, average_n_slopes, remove_n_largest):
        '''takes a TECAN input file (.xlsx) and outputs a results file with maximum slopes calculated for each well and each sheet.

        input_file: path and name of the TECAN file (.xlsx)
        output_file: patch and name if the output file (default=current working directory + output_file.xlsx).
        interval: Interval between two datapoints used for calculating slopes. Can alternatively be set for each Sheet individually by placing a number between 1-200 in cell A1 of Sheet
        containing TECAN data(default=10).
        run_images: If set to yes, a graphical representation of the calculated slopes is displayer for each measurement (default="No").
        romove_n_largest: removes the n largest slopes for each measurement (in %/100). Higher values increase robustness against outliers.
        average_n_slopes: number of maximum slopes used to calculate the averaged maximum slopes. Higher values increase robustness against outliers'''

        self.input_file = input_file
        self.output_file = output_file
        self.interval = interval_
        self.run_images = run_images
        self.master_df = pd.DataFrame()
        for sheet_name in pd.read_excel(self.input_file, sheet_name=None).keys():
            try:
                try:
                    #Kinetc data in a TECAN file starts in row 33 and in column 2.
                    #A measurement for one well in stored in a column. Measurements for multiple wells are sored as horizontally stacked columns.
                    #This line extracts the TECAN data from a Sheet.
                    self.current_sheet_df = pd.read_excel(self.input_file, sheet_name=sheet_name).iloc[33:][2:].reset_index(drop=True)
                    #if cell A1 of the selected Sheet features a number between 1-200, the interveal used for calculating slopes will be set to the number in cell A1.
                    #This allopws to use different intervals for different Sheets.
                    if self.current_sheet_df.columns[0] in list(range(1, 200)):
                        self.interval = self.current_sheet_df.columns[0]
                    else:
                        self.interval = self.interval
                #This allows handling files with completely empty Sheets.
                # An empty Sheet will lead to an IndexError as df.columns[0] will be out of bounds.
                except IndexError:
                    pass

                self.column_names = self.current_sheet_df.loc[0].to_list()
                self.current_sheet_df.columns = self.column_names

                #Dropping rows and columns, that are not needed for further analysis
                self.current_sheet_df.drop(0, inplace=True, axis=0)
                self.current_sheet_df.drop([self.column_names[2], self.column_names[0]], axis=1, inplace=True)

                #A transpose of the TECAN data will be used for further analysis featuring a measurement for one welll in one row.
                #Kinetic data for different wells is stored as vertically stacked rows.
                self.current_sheet_df = self.current_sheet_df.T
                self.current_sheet_df.columns = pd.RangeIndex(start=0, stop=len(self.current_sheet_df.columns), step=1)

                #Make sure that only numbers are present in the TECAN data.
                for i in self.current_sheet_df.columns:
                    self.current_sheet_df[i] = pd.to_numeric(self.current_sheet_df[i], errors='coerce')

                #Make kinetic data lines smooth using the Savitzky-Golay-filter
                self.df_smooth = self.current_sheet_df
                for row in self.df_smooth.index[1:]:
                    self.df_smooth.loc[row] = savgol_filter(self.current_sheet_df.loc[row], window_length=15, polyorder=3)

                #Calculate slopes for all intervalls of n data points
                self.df_smooth['slope_lists'] = self.df_smooth.apply(lambda x: self.calculate_slopes(x, self.df_smooth.iloc[0], self.interval),axis=1)

                #Select the n largest slopes from all slopes calculated and calculate the mean of the n largest slopes and store the indices of the n largest slopes.
                self.df_smooth['n_largest_slopes'] =self.df_smooth['slope_lists'].apply(lambda x: self.n_largest_slopes(x, average_n_slopes=average_n_slopes, remove_n_largest=remove_n_largest))
                self.df_smooth['final_slope'] = self.df_smooth['n_largest_slopes'].apply(lambda x: x[0].mean())
                self.df_smooth['indices_final_slopes'] = self.df_smooth['n_largest_slopes'].apply(lambda x: x[1])

                self.master_df[''] = None
                self.master_df = pd.concat([self.master_df, self.df_smooth.final_slope[1:]], axis=1)
                self.master_df = self.master_df.rename(columns={'final_slope':sheet_name})

                if self.run_images.lower() == 'yes':
                    self.run_images_funct()

            except KeyError:
                pass

        self.output_file = output_file
        self.master_df.T.to_excel(self.output_file)

    def run_images_funct(self):
        '''Displays an image of the smoothed kinetic curve used for calculating n maximum slopes with a set interval'''
        for i in self.df_smooth.index[1:]:
            plt.plot(self.df_smooth.loc[self.df_smooth.index[0]][:-4], self.df_smooth.loc[i][:-4])
            for j in range(len(self.df_smooth.loc[i, self.df_smooth.columns[-1]])):
                self.x_low = self.df_smooth.loc[
                    self.df_smooth.index[0], self.df_smooth.loc[i, self.df_smooth.columns[-1]][j]]
                self.x_high = self.df_smooth.loc[
                    self.df_smooth.index[0], self.df_smooth.loc[i, self.df_smooth.columns[-1]][j] + self.interval]
                self.y_low = self.df_smooth.loc[i, self.df_smooth.loc[i, self.df_smooth.columns[-1]][j]]
                self.y_high = self.df_smooth.loc[
                    i, self.df_smooth.loc[i, self.df_smooth.columns[-1]][j] + self.interval]
                plt.plot([self.x_low, self.x_high], [self.y_low, self.y_high], )
            plt.show()


class CalculateSlopes():
    '''This class takes a TECAN input file (.xlsx) and generates an output file providing the maximum slopes for each measurement.
    If several Sheets are presentin the input file, the results for each maesurement are provided in one row per sheet, with rows for multiple Sheets stacked vertically.

    Attributes:
        input_file: path and name of the TECAN file (.xlsx)
        output_file: patch and name if the output file (default=current working directory + output_file.xlsx)
        run_images: If set to yes, a graphical representation of the calculated slopes is displayer for each measurement (default="No")
        default_interval: Interval between two datapoints used for calculating slopes. Can alternatively be set for each Sheet individually by placing a number between 1-200 in cell A1 of Sheet
        containing TECAN data(default=10).
        romove_n_largest: removes the n largest slopes for each measurement (in %/100). Higher values increase robustness against outliers.
        average_n_slopes: number of maximum slopes used to calculate the averaged maximum slopes. Higher values increase robustness against outliers

    The Savitzky-Golay-filter is used for smoothing corves.
    To genearte an output file instantiate an class-object providing all neccesary attributes.'''

    def __init__(self, input_file, output_file=os.path.join(os.getcwd(), 'output_file.xlsx'), run_images='No', default_interval=10, average_n_slopes=3, romove_n_largest=0.07):
        #Select if graphic representation of the slopes should be displayer for each activity curve
        # run_images = 'yes': display images.
        self.run_images = run_images
        self.output_file = output_file

        #Select interval between tw measuring points, to calculate slopes.
        #If cell A1 in the respective excel sheet of does not feature a number between 1-200, the interval_default value will be used.
        self.interval = default_interval

        #Input file as .xlsx file. The input file can feature several sheets with TECAN data and other data as well. Sheets containing non-TECAN data will be skipped.
        self.input_file = pd.ExcelFile(input_file)
        self.utils = Utils()
        self.utils.create_output_file(self.input_file, self.output_file, self.interval,self.run_images,average_n_slopes=average_n_slopes,remove_n_largest=romove_n_largest)

if __name__ == '__main__':
    input_file = 'D:\\Bodenproben_Glucosidase_Phosphatase_11_12_23.xlsx'
    outpu_file= 'D:\\Results_13.12.23.xlsx'

    CalculateSlopes(input_file, outpu_file, run_images='no', default_interval=30)
